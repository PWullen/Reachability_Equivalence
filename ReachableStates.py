# reachable states
"""write a python program using the functions in PyEDA to implement the BFS algorithm with
the constrain operator that computes the reachable states of a state machine using image
computation. The input to your algorithm should be a state machine described in the KISS
format (Keep It Simple and Stupid). This is part of the BLIF (Berkeley Logic Interchange
Format) and is described in the file blif.pdf on the course website under Files. Demonstrate
your procedure on the state machine shown in Figure 1. Generate a table that shows the From
states, the New states and the Reached states, from the initial state 0."""
import collections
import numpy as np
import pyeda
from pyeda.inter import *
from pyeda.boolalg.bdd import _expr2bddnode
#Importing expr2bddnode for DFS operations

def BFS(node, visited):
    """utilize constrain operator that computes the reachables states of a state machine using image computation"""
    print("running BFS")
    queue = collections.deque()
    queue.appendleft(node)
    while queue:
        node = queue.pop()
        if node not in visited:
            if node.lo is not None:
                queue.appendleft(node.lo)
            if node.hi is not None:
                queue.appendleft(node.hi)
            visited.add(node)
            yield node

def BFSans(self):
    yield from BFS(self.node, set())

def BFS_FSM(S, X, delta, Z, S0):
    """input: state transition graph and initial states
       output: set of reachable states from S0
       S = set of states
       X =
       delta = state transition function
       Z = output function
       S0 = initial states
       """
    print("running bfs from lecture pseudocode")
    Reached = From = new(0) = S0
    k = 0
    while new(k) is not None:
        k = k + 1
        To = IMG(delta, From)
        new(k) = To - Reached
        From = new(k)
        Reached = union(Reached, new(k))
    return(new(j) for j in range(0,k-1))

def Constrain(f,g):
    """valid generalized cofactor is generated by reduction of bdd via constrain operator
       input: ROBDDs f and g
       output: constrained fvg"""
    x = BDDNode
    if g == 0 or f == 0 or f == 1:
        return f
    elif f == g:
        return 1
    elif f ==  ~g or g == 0:
        return 0
    elif g.x == 0:
        return Constrain(~f.x, ~g.x)
    elif ~g.x == 0:
        return Constrain(f.x, g.x)
    else:
        return ITE(x, Constrain(f.x, g.x), Constrain(~f.x, ~g.x))

def IMG(f,C):
    """To compute the Image restricted to a subset C,
       we can compute the Range of another function, namely Constrain(f, C)"""
    #1
    #treating f as a function IMG(f) is done by recursive cofactoring input splitting/output splitting
    """
    #input splitting
    if f.x == ~f.x:  #terminal case 1, f is constant
        yield f
    elif for i, j in range(1, m) of f:  #terminal case 2, IM(f) is disjoint set of partitioned groups
        if union(support(f.i), support(f.j)) == None:
            yield IMG(f.k) in range(1,k)
    elif f.y == f.y:  #terminal case 3, equality of component functions
        yield f
    """

    #output splitting
    IM = y.i & IMG(f.i, ONset(f)) | ~y.i & IMG(f.i, ONset(~f))


    #2
    #in IMG(f), treat f as a relation, and perform quantification

def Wullen_ReachableStates():
    print("running reachable states")
