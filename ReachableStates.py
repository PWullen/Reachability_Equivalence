"""utilize constrain operator that computes the reachables states of a state machine using image computation"""

"""write a python program using the functions in PyEDA to implement the BFS algorithm with
the constrain operator that computes the reachable states of a state machine using image
computation. The input to your algorithm should be a state machine described in the KISS
format (Keep It Simple and Stupid). This is part of the BLIF (Berkeley Logic Interchange
Format) and is described in the file blif.pdf on the course website under Files. Demonstrate
your procedure on the state machine shown in Figure 1. Generate a table that shows the From
states, the New states and the Reached states, from the initial state 0."""
import collections
import functools
import operator
import pyeda
from pyeda.inter import *
import blifparser.blifparser as blifparser
from pyeda.boolalg.bdd import _expr2bddnode
#Importing expr2bddnode for DFS operations

"""following code copied from PyEDA as imports cause conflicts"""
def BFS(node, visited):
    """
    pulled from PyEDA source code as import was non-operational

    :param node: BDDNode class input

    :param visited: loop setup for queue
    """
    queue = collections.deque()
    queue.appendleft(node)
    while queue:
        node = queue.pop()
        if node not in visited:
            if node.lo is not None:
                queue.appendleft(node.lo)
            if node.hi is not None:
                queue.appendleft(node.hi)
            visited.add(node)
            yield node

def BFSans(self):
    """Pulled from PyEDA source to grab BFS info.

    :return: outputs a set of nodes traverse in BFS
    """
    yield from BFS(self.node, set())

def smoothing(self, vs=None):
    r"""Return the smoothing of a function over a sequence of N variables.

    The *vs* argument is a sequence of :math:`N` Boolean variables.

    The *smoothing* of :math:`f(x_1, x_2, \dots, x_i, \dots, x_n)` with
    respect to variable :math:`x_i` is:
    :math:`S_{x_i}(f) = f_{x_i} + f_{x_i'}`

    This is the same as the existential quantification operator:
    :math:`\exists \{x_1, x_2, \dots\} \: f`
    """
    return functools.reduce(operator.or_, self.iter_cofactors(vs))

def iter_cofactors(self, vs=None):
    r"""Iterate through the cofactors of a function over N variables.

    The *vs* argument is a sequence of :math:`N` Boolean variables.

    The *cofactor* of :math:`f(x_1, x_2, \dots, x_i, \dots, x_n)`
    with respect to variable :math:`x_i` is:
    :math:`f_{x_i} = f(x_1, x_2, \dots, 1, \dots, x_n)`

    The *cofactor* of :math:`f(x_1, x_2, \dots, x_i, \dots, x_n)`
    with respect to variable :math:`x_i'` is:
    :math:`f_{x_i'} = f(x_1, x_2, \dots, 0, \dots, x_n)`
    """
    vs = self._expect_vars(vs)
    for point in iter_points(vs):
        yield self.restrict(point)

def cofactors(self, vs=None):
    r"""Return a tuple of the cofactors of a function over N variables.

    The *vs* argument is a sequence of :math:`N` Boolean variables.

    The *cofactor* of :math:`f(x_1, x_2, \dots, x_i, \dots, x_n)`
    with respect to variable :math:`x_i` is:
    :math:`f_{x_i} = f(x_1, x_2, \dots, 1, \dots, x_n)`

    The *cofactor* of :math:`f(x_1, x_2, \dots, x_i, \dots, x_n)`
    with respect to variable :math:`x_i'` is:
    :math:`f_{x_i'} = f(x_1, x_2, \dots, 0, \dots, x_n)`
    """
    return tuple(cf for cf in self.iter_cofactors(vs))


"""end of PyEDA source copy"""


def union(a, b):
    """
    simple equation to yield logical OR
    """
    ans = a | b
    yield ans

def Constrain(f, g):
    """valid generalized cofactor is generated by reduction of bdd via constrain operator

       :param f: ROBDD f
       :param g: ROBDD g
       :return: constrained fvg"""
    x = BDDNode
    if g == 0 or f == 0 or f == 1:
        return f
    elif f == g:
        return 1
    elif f ==  ~g or g == 0:
        return 0
    elif g.x == 0:
        return Constrain(~f.x, ~g.x)
    elif ~g.x == 0:
        return Constrain(f.x, g.x)
    else:
        return ITE(x, Constrain(f.x, g.x), Constrain(~f.x, ~g.x))


def IMG(f, C):
    """To compute the Image restricted to a subset C,
       we can compute the Range of another function, namely Constrain(f, C)"""
    #output splitting
    #IM = y.i & IMG(f.i, ONset(f)) | ~y.i & IMG(f.i, ONset(~f))
    #2 found in page 318 + 324 of book LOGIC SYNTHESIS
    #in IMG(f), treat f as a relation, and perform quantification
    f = smoothing(f)


def StateTransitionTable(fig1):
    """
    :param fig1: utilizing 3 bits for the 7 states 0,...,6
    :return: TT of 14 rows
    """
    print("generating delta")
    return fig1



def Wullen_ReachableStates():
    print("running reachable states")
    S = {0, 1, 2, 3, 4, 5, 6}
    S0 = 0
    delta = StateTransitionTable(S0)
    BFS(IMG(delta, S), S0)
