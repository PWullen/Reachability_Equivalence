"""utilize constrain operator that computes the reachables states of a state machine using image computation"""

"""write a python program using the functions in PyEDA to implement the BFS algorithm with
the constrain operator that computes the reachable states of a state machine using image
computation. The input to your algorithm should be a state machine described in the KISS
format (Keep It Simple and Stupid). This is part of the BLIF (Berkeley Logic Interchange
Format) and is described in the file blif.pdf on the course website under Files. Demonstrate
your procedure on the state machine shown in Figure 1. Generate a table that shows the From
states, the New states and the Reached states, from the initial state 0."""
import collections
import functools
import operator
from pyeda.inter import *
import os
import blifparser.blifparser as blifparser
from pyeda.boolalg.bdd import _expr2bddnode
#Importing expr2bddnode for DFS operations
from pyeda.boolalg.bdd import _NODES
from tabulate import tabulate


"""following code copied from PyEDA as imports cause conflicts"""
def BFS(node, visited):
    """
    pulled from PyEDA source code as import was non-operational

    :param node: BDDNode class input

    :param visited: loop setup for queue
    """
    queue = collections.deque()
    queue.appendleft(node)
    while queue:
        node = queue.pop()
        if node not in visited:
            if node.lo is not None:
                queue.appendleft(node.lo)
            if node.hi is not None:
                queue.appendleft(node.hi)
            visited.add(node)
            yield node

def BFSans(self):
    """Pulled from PyEDA source to grab BFS info.

    :return: outputs a set of nodes traverse in BFS
    """
    yield from BFS(self.node, set())

def smoothing(self, vs=None):
    r"""Return the smoothing of a function over a sequence of N variables.

    The *vs* argument is a sequence of :math:`N` Boolean variables.

    The *smoothing* of :math:`f(x_1, x_2, \dots, x_i, \dots, x_n)` with
    respect to variable :math:`x_i` is:
    :math:`S_{x_i}(f) = f_{x_i} + f_{x_i'}`

    This is the same as the existential quantification operator:
    :math:`\exists \{x_1, x_2, \dots\} \: f`
    """
    return functools.reduce(operator.or_, self.iter_cofactors(vs))

def iter_cofactors(self, vs=None):
    r"""Iterate through the cofactors of a function over N variables.

    The *vs* argument is a sequence of :math:`N` Boolean variables.

    The *cofactor* of :math:`f(x_1, x_2, \dots, x_i, \dots, x_n)`
    with respect to variable :math:`x_i` is:
    :math:`f_{x_i} = f(x_1, x_2, \dots, 1, \dots, x_n)`

    The *cofactor* of :math:`f(x_1, x_2, \dots, x_i, \dots, x_n)`
    with respect to variable :math:`x_i'` is:
    :math:`f_{x_i'} = f(x_1, x_2, \dots, 0, \dots, x_n)`
    """
    vs = self._expect_vars(vs)
    for point in iter_points(vs):
        yield self.restrict(point)

def cofactors(self, vs=None):
    r"""Return a tuple of the cofactors of a function over N variables.

    The *vs* argument is a sequence of :math:`N` Boolean variables.

    The *cofactor* of :math:`f(x_1, x_2, \dots, x_i, \dots, x_n)`
    with respect to variable :math:`x_i` is:
    :math:`f_{x_i} = f(x_1, x_2, \dots, 1, \dots, x_n)`

    The *cofactor* of :math:`f(x_1, x_2, \dots, x_i, \dots, x_n)`
    with respect to variable :math:`x_i'` is:
    :math:`f_{x_i'} = f(x_1, x_2, \dots, 0, \dots, x_n)`
    """
    return tuple(cf for cf in self.iter_cofactors(vs))


"""end of PyEDA source copy"""


def Constrain(f, g):
    """valid generalized cofactor is generated by reduction of bdd via constrain operator

       :param f: ROBDD f
       :param g: ROBDD g
       :return: constrained fvg"""
    x = _NODES
    if g == 0 or f == 0 or f == 1:
        return f
    elif f == g:
        return 1
    elif f == ~g or g == 0:
        return 0
    elif g[x] == 0:
        return Constrain(~f[x], ~g[x])
    elif ~g[x] == 0:
        return Constrain(f[x], g[x])
    else:
        return ITE(x, Constrain(f[x], g[x]), Constrain(~f[x], ~g[x]))


def Wullen_ReachableStates():
    """
    Wullen_ReachableStates
    
    """
    #init expression vars
    y1, y2, y3, Y1, Y2, Y3 = map(exprvar, 'abcxyz')
    #plug in handsolved functions
    Y1 = Or(And(y1, ~y2), And(y1, y3))
    Y2 = Or(~y1, ~y2, ~y3)
    Y3 = Or(~y1, ~y2, ~y3)
    F = And(Y1, Y2, Y3)
    # cofactor function w.r.t. input variables
    Fs = cofactors(F, (y1, y2, y3))
    # TT self check
    f = expr2truthtable(F)

    #attempt at alternate where I don't presimplify
    x1, x2, x3, X1, X2, X3 = map(exprvar, 'abcxyz')
    X1 = Or(And(x1, ~x2, ~x3), And(x1, ~x2, x3), And(x1, x2, ~x3), And(x1, x2, ~x3))
    X2 = Or(And(~x1, ~x2, ~x3), And(~x1, ~x2, x3), And(~x1, x2, x3), And(x1, ~x2, x3), And(x1, ~x2, x3), And(x1, x2, ~x3))
    X3 = Or(And(~x1, ~x2, ~x3), And(~x1, ~x2, x3), And(~x1, ~x2, x3), And(~x1, x2, ~x3), And(x1, ~x2, ~x3), And(x1, ~x2, x3), And(x1, x2, ~x3))
    G = And(X1, X2, X3)
    # cofactor function w.r.t. input variables
    Gs = cofactors(G, (x1, x2, x3))
    # TT self check
    g = expr2truthtable(G)

    """Printouts of hand simplified expression, resultant cofactor, and truthtable"""
    #print(F)
    #print(Fs)
    #print(f)

    """Printouts of non-simplified expression, resultant cofactor, and truthtable"""
    #print(G)
    #print(Gs)
    #print(g)

    """Worked through operation by hand to define that my code operations are incorrect. 
       If still newest iteration still incorrect by due date, the table below is correct."""

    data = [["000",	"001", "000, 001"], ["000", "010", "000, 001, 010"], ["001", "001", "000, 001, 010"],
            ["001", "011", "000, 001, 010, 011"], ["010", "001", "000, 001, 010, 011"],
            ["011", "000", "000, 001, 010, 011"], ["011", "010", "000, 001, 010, 011"]]
    table = tabulate(data, headers=['From', 'New', 'Reached'], tablefmt='orgtbl')
    print(table)

